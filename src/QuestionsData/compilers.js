const compilers = [
    {
        text: "Which of the following strings is not generated by the following grammar? S → SaSbS|ε",
        options: ["None of the choices",
            "aabb",
            "abab",
            "aababb",
            "All of the choices"]
    },
    {
        text: "The production Grammar is {S->aSbb,S->abb} is Type ____ grammar.",
        options: ["2", "0", "1", "3", "None of the choices"]
    },
    {
        text: "A system program that combines separately compiled modules of a program into a form suitable for execution is called ___________",
        options: ["Linking loader",
            "Assembler",
            "Cross compiler",
            "None of the mentioned"]
    },
    {
        text: "A compiler for a high-level language that runs on one machine and produces code for a different machine is called ___________",
        options: ["Cross compiler",
            "Optimizing compiler",
            "One pass compiler",
            "Multipass compiler"]

    },
    {
        text: "Cross-compiler is a compiler __________",
        options: ["That runs on one machine but produces object code for another machine",
            "Which is written in a different language from the source language",
            "That generates object code for the machine it’s running on.",
            "Which is written in the same language as the source language"]

    },
    {
        text: "Cross compiler is used in Bootstrapping.",
        ans: true
    },
    {
        text: "What is the output of lexical analyzer?",
        options: ["Set of Tokens",
            "A set of regular expressions",
            "Syntax Tree",
            "String Character",
        ]
    },
    {
        text: "Which symbol table implementation is based on the property of locality of reference?",
        options: ["Self Organisation",
            "Linear list",
            "Search tree",
            "Hash Table",
        ]
    },
    {
        text: "In operator precedence parsing, precedence relations are defined",
        options: ["For all pair of non-terminals",
            "For all pair of terminals",
            "To delimit the handle",
            "None of the mentioned",
            "For all terminals and non-terminals",
        ]
    },
    {
        text: "What is an Object program?",
        options: ["Translation of high-level language into machine language",
            "Program written in machine language",
            "Program to be translated into machine language",
            "None of the mentioned",
        ]
    },
    {
        text: "Which concept of FSA is used in the compiler?",
        options: ["Lexical analysis",
            "Parser",
            "Code generation",
            "Code optimization",
        ]
    },
    {
        text: "Which concept of grammar is used in the compiler?",
        options: ["Parser",
            "Lexical analysis",
            "Code generation",
            "Code optimization",
        ]
    },
    {
        text: "Which of the following are Lexemes?",
        options: ["All of the mentioned",
            "Identifiers",
            "Constants",
            "Keywords",
        ]
    },
    {
        text: "What constitutes the stages of the compilation process in order?",
        options: ["Lexical analysis, Syntax, Analysis and code generation",
            "Feasibility study, system, design, and testing",
            "Implementation and documentation",
            "None of the mentioned",
        ]
    },
    {
        text: "The lexical analyzer takes _________ as input and produces a stream of _______ as output.",
        options: ["Source program, lexis",
            "Object program, tokens",
            "Either of the two",
            "None of the mentioned",
        ]
    },
    {
        text: "Parsing is also known as ________",
        options: ["Syntax Analysis",
            "Lexical Analysis",
            "Semantic Analysis",
            "Code Generation",
        ]
    },
    {
        text: "A compiler program written in a high level language is called ________",
        options: ["Source Program",
            "Object Program",
            "Machine Language Program",
            "None of the mentioned",
        ]
    },
    {
        text: "System program such a compiler are designed so that they are ________",
        options: ["Re-enterable",
            "Non-Usable",
            "Serially usable",
            "None of the mentioned",
        ]
    },
    {
        text: "Which of the following is not a feature of compiler?",
        options: ["Scan the entire program first and translate into machine code",
            "To remove syntax errors",
            "Slow for debugging",
            "Execution time is more",
        ]
    },
    {
        text: "A system program that brings together separately compiled modules of a program into a form language that is suitable for execution.",
        options: ["Linking loader",
            "Assembler",
            "Cross compiler",
            "None of the mentioned",
        ]
    },
    {
        text: "Which of the following can be generated by S->aS|bA, A->d|ccA",
        options: ["aabccd",
            "adabcca",
            "abcca",
            "abababd",
            "None of the mentioned",
        ]
    },
    {
        text: "The regular expression in which any number of 0′s is followed by any number of 1′s followed by any number of 2′s is?",
        options: ["None of the mentioned",
            "(0+1+2)*",
            "(012)*",
            "0* + 1 + 2",
            "(0+1)*2*",
        ]
    },
    {
        text: "The regular expression have all strings of 0′s and 1′s with no two consecutive 0′s is?",
        options: ["(0+ε)(1+10)*",
            "(0+1)",
            "(0+1)*",
            "(0+1)* 011",
        ]
    },
    {
        text: "Which of the following is NOT the set of regular expression R = (ab + abb)* bbab?",
        options: ["abababab",
            "ababbbbab",
            "abbbab",
            "ababbabbbab",
        ]
    },
    {
        text: "A language L from a grammar G = { VN, Σ, P, S} is?",
        options: ["Set of symbols over VN",
            "Set of symbols over Σ",
            "Set of symbols over P",
            "Set of symbols over S",
            "All of the mentioned",
        ]
    },
    {
        text: "What is the transitional function of a DFA?",
        options: ["Q × Σ → Q",
            "Q × Σ → δQ",
            "Q × Σ → δn",
            "Q × Σ → Qn",
        ]
    },
    {
        text: "What is the transitional function of a NFA? (assuming ε in Σ)",
        options: ["Q × Σ → δQ",
            "Q × Σ → Q",
            "Q × Σ → δn",
            "Q × Σ → Qn",
        ]
    },
    {
        text: "The Kleene closure of regular expression r is expressed as:",
        options: ["r*",
            "r+",
            "{r}",
            "[r]",
            "r",
        ]
    },
    {
        text: "Which of the following cannot be expressed using a regular expression?",
        options: ["a string that contains a prime number of b's",
            "a string that contains exactly one b",
            "a string that contains at most five b's",
            "a string that contains a number of b's divisble by 3 or 5",
        ]
    },
    {
        text: "What are the basic limitations of finite state machine?",
        options: ["In cannot remember state transitions",
            "It cannot remember arbitrarily large amount of information",
            "In cannot remember grammar for a language",
            "It cannot remember language generated from a grammar",
        ]
    },
    {
        text: "A finite automata recognizes ____________",
        options: ["Regular Language",
            "Context Sensitive Language",
            "Context Free Language",
            "All of the mentioned",
        ]
    },
    {
        text: "Conversion of a DFA to an NFA __________",
        options: ["Requires the subset construction",
            "Is impossible",
            "Is Chancy",
            "Is nondeterministic",
        ]
    },
    {
        text: "The transitions which does not take an input symbol are called ___________",
        options: ["ε-transitions & λ-transitions",
            "ε-transitions",
            "λ-transitions",
            "none of the mentioned",
        ]
    },
    {
        text: "Which of the following derivations does a top-down parser use while parsing an input string?",
        options: ["Leftmost derivation",
            "Leftmost derivation in reverse",
            "Rightmost derivation",
            "Rightmost derivation in reverse",
            "Leftmost derivation or Rightmost derivation in reverse",
        ]
    },
    {
        text: "The process of assigning load addresses to the various parts of the program and adjusting the code and data in the program to reflect the assigned addresses is called?",
        options: ["Relocation",
            "Assembly",
            "Parsing",
            "Symbol resolute",
        ]
    },
    {
        text: "Which of the following statements is false?",
        options: ["Left as well as right most derivations can be in Unambiguous grammar",
            "An LL (1) parser is a top-down parser",
            "LALR is more powerful than SLR",
            "Ambiguous grammar can’t be LR (k)",
        ]
    },
    {
        text: "Which of the following grammar rules violate the requirements of an operator grammar? (i) P -> QR (ii) P -> QsR (iii) P -> ε (iV) P -> QtRr",
        options: ["(i) and (iii) only",
            "(i) only",
            "(ii) and (iii) only",
            "(iii) and (iv) only",
        ]
    },
    {
        text: "Which of the following suffices to convert an arbitrary CFG to an LL(1) grammar?",
        options: ["Neither",
            "Removing left recursion",
            "Factoring the grammar",
            "Both",
        ]
    },
    {
        text: "Assume that the SLR parser for a grammar G has n states and the LALR parser for G has m states. Which of the following is correct?",
        options: ["n is necessarily equal to m",
            "n is necessarily less than m",
            "n is necessarily greater than m",
            "All are incorrect",
        ]
    },
    {
        text: "Which of the following is true?\nI.  There exist parsing algorithms for some programming languages which has O(3) complexity.\nII.  A programming language which allows recursion can be implemented with static storage allocation.\nIII. No L-attributed definition can be evaluated in The framework of bottom-up parsing.\nIV. Code improving transformations can be performed at both intermediate code level and source Language.",
        options: ["I and IV",
            "I and II",
            "III and IV",
            "I III and IV",
        ]
    },
    {
        text: "Which of the following describes a handle (as applicable to LR-parsing) appropriately?",
        options: ["Used in the next step for reduction along with a position in the sentential form where the right hand side of the production may be found",
            "Position where next reduce or shift operation will occur",
            "The next step has use of Non-terminal for reduction",
            "Used for reduction in a coming-up step along with a position in the sentential form where the next shift or reduce operation will occur",
        ]
    },
    {
        text: "Which one of the following is a top-down parser?",
        options: ["LL(1)",
            "LR(1)",
            "SLR(1)",
            "LALR(1)",
        ]
    },
    {
        text: "For the grammar E → E + n | E × n | n  and the sentence n + n × n, the handles in the right-sentential form of the reduction are __________",
        options: ["n, E + n and E × n",
            "n, E + n and E + n × n",
            "n, E + n and E + n × n",
            "n, n + n and n + n × n",
        ]
    },
    {
        text: "What is the grammar for S → CC, C → cC|d",
        options: ["LL(1)",
            "SLR(1) but not LL(1)",
            "LALR(1) but not SLR(1)",
            "LR(1) but not LALR(1)",
        ]
    },
    {
        text: "Which of the following statements is false?",
        options: ["Unambiguous grammar has both kind of derivations",
            "An LL(1) parser is a top-down parser",
            "LALR is more powerful than SLR",
            "Ambiguous grammar can’t be LR(k)",
        ]
    },
    {
        text: "Which one of the following is true at any valid state in shift-reduce parsing?",
        options: ["Stack contains only viable prefixes",
            "At the bottom we find the prefixes",
            "None of the mentioned",
            "Stack consists of viable prefixes",
        ]
    },
    {
        text: "If a grammar is LR(l), then the LALR(l) parsing table can have",
        options: ["reduce-reduce conflicts",
            "shift-reduce conflicts",
            "both",
            "neither",
        ]
    },
    {
        text: "The grammar S → F ⎪ H, F → p ⎪ c, H → d ⎪ c is",
        options: ["Neither",
            "LL(1)",
            "LR(1)",
            "Both",
        ]
    },
    {
        text: "What is the maximum number of reduce moves that can be taken by a bottom-up parser for a grammar with no epsilon- and unit-production to parse a string with n tokens?",
        options: ["n-1",
            "n/2",
            "2n-1",
            "2^n",
        ]
    },
    {
        text: "YACC builds up __________",
        options: ["LALR parsing table",
            "SLR parsing table",
            "LR(1) parsing table",
            "LL(1) parsing table",
        ]
    },
    {
        text: "The action of parsing the source program into proper syntactic classes is called __________",
        options: ["Lexical Analysis",
            "Syntax Analysis",
            "Interpretation analysis",
            "General Syntax Analysis",
        ]
    },
    {
        text: "Shift reduce parsers are __________",
        options: ["Bottom up parser",
            "Top down parser",
            "Either",
            "Neither",
        ]
    },
    {
        text: "A bottom up parser generates __________",
        options: ["Right most derivation in reverse",
            "Right most derivation",
            "Left most derivation",
            "Left most derivation in reverse",
        ]
    },
    {
        text: "A shift reduce parser carries out the actions specified within braces immediately after reducing with the corresponding rule S-> xxW {PRINT “1”}, S-> y { print ” 2 ” }, W-> Sz { print ” 3 ” } What is the translation of xxxxyzz using the syntax directed translation scheme described by the above rules?",
        options: ["23131",
            "21233",
            "23213",
            "21133",
        ]
    },
    {
        text: "LR parsers are attractive because _________",
        options: ["It can be constructed to recognize CFG corresponding to almost all programming constructs & It does not backtrack",
            "It can be constructed to recognize CFG corresponding to almost all programming constructs",
            "It does not backtrack",
            "None of the mentioned",
        ]
    },
    {
        text: "Which is the most powerful parser?",
        options: ["Canonical LR",
            "SLR",
            "LALR",
            "Recursive-Descend",
        ]
    },
    {
        text: "What is terminal table?",
        options: ["Is a permanent table which lists all keywords and special symbols of the language in symbolic form",
            "Contains all constants in the program",
            "Is a permanent table of decision rules in the form of patterns for matching with the uniform symbol table to discover syntactic structure",
            "Consist of a full or partial list of the token is as they appear in the program created by lexical analysis and used for syntax analysis and interpretation",
        ]
    },
    {
        text: "What is Uniform symbol table?",
        options: ["Consists of full or partial list of the tokens as they appear in the program created by Lexical analysis and used for syntax analysis and interpretation",
            "Has all constants in the program",
            "Permanent table of rules in the form of patterns for matching with the uniform symbol table to discover syntactic structure",
            "A permanent table which has all key words and special symbols of the language in symbolic form",
        ]
    },
    {
        text: "Which of these is also known as look-head LR parser?",
        options: ["LALR",
            "SLR",
            "Canonical LR",
            "All of the mentioned",
        ]
    },
    {
        text: "What is the similarity between LR, LALR and SLR?",
        options: ["Use same algorithm, but different parsing table",
            "Same parsing table, but different algorithm",
            "Their Parsing tables and algorithm are similar but uses top down approach",
            "Both Parsing tables and algorithm are different",
        ]
    },
    {
        text: "An LR-parser can detect a syntactic error as soon as __________",
        options: ["It is possible to do so a left-to-right scan of the input",
            "The parsing starts",
            "It is possible to do so a right-to-left scan of the input",
            "Parsing ends",
        ]
    },
    {
        text: "Which of these is true about LR parsing?",
        options: ["Is most general non-backtracking shift-reduce parsing & It is still efficient",
            "Is most general non-backtracking shift-reduce parsing",
            "It is still efficient",
            "None of the mentioned",
        ]
    },
    {
        text: "The construction of the canonical collection of the sets of LR (1) items are similar to the construction of the canonical collection of the sets of LR (0) items. Which is an exception?",
        options: ["Closure and goto operations work a little bit different",
            "Closure and goto operations work similarly",
            "Closure and additive operations work a little bit different",
            "Closure and associatively operations work a little bit different",]
    },
    {
        text: "For any DFA state {qi,qj…qm} If some qj is a final state in the NFA Then {qi,qj…qm}, is a final state in the DFA.",
        ans: true
    },

    {
        text: "Adding an epsilon ring to a state in an NFA affects the behaviour of the NFA.",
        ans: false
    },

    {
        text: "The production of the form no terminal -> ε is said to be null production.",
        ans: true
    },

    {
        text: "LR-parser finds errors earlier than LALR-parser",
        ans: true
    },
]

export default compilers